<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geospatial Data Viewer</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js for mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Core dependencies for GeoTIFF parsing and display -->
    <script src="https://unpkg.com/georaster"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet"></script>
    
    <!-- Turf.js for geospatial analysis (e.g., bounding box) -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>

    <!-- Leaflet Plugins -->
    <!-- Leaflet.Measure for measurement tools -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure@3.1.0/dist/leaflet-measure.css">
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure@3.1.0/dist/leaflet-measure.min.js"></script>

    <!-- Leaflet.draw for drawing tools -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <!-- Quill WYSIWYG Editor -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

    <!-- Chroma.js for color scales -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>

    <!-- JSZip for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        /* Use Inter font from Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for leaflet popups and controls */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }
        .leaflet-control-layers {
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        /* Style for the selected annotation item */
        .annotation-item.selected {
            background-color: #e0f2fe; /* light blue */
            border-left-width: 4px;
            border-color: #0ea5e9; /* sky-500 */
        }
        /* Ensure the snapshot map is not interactive */
        #snapshot-map {
            pointer-events: none;
        }
        /* Legend styles */
        .legend {
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            line-height: 1.2;
        }
        .legend-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .legend-gradient {
            height: 150px;
            width: 20px;
            border: 1px solid #ccc;
        }
        .legend-labels {
            position: relative;
            height: 150px;
            width: 40px;
        }
        .legend-labels span {
            position: absolute;
            right: 0;
            transform: translateY(-50%);
            font-size: 10px;
        }
        /* Modal and Loader Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.3s ease;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 600px; /* Wider for editor */
            max-height: 90vh;
            overflow-y: auto;
        }
        .hidden {
            display: none;
        }
        /* Quill editor height */
        #quill-editor {
            height: 200px;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        
        <!-- Header Section -->
        <header class="bg-white p-6 rounded-xl shadow-md mb-8 border border-gray-200 relative">
            <div class="flex flex-col items-center gap-4 text-center">
                <img id="logo-img" src="https://placehold.co/80x80/e2e8f0/334155?text=Logo" alt="Logo" class="h-20 w-20 rounded-full object-cover cursor-pointer mb-2">
                <input type="file" id="logo-input" class="hidden" accept="image/*">
                <div>
                    <h1 id="main-title" class="text-3xl font-bold text-gray-900">Site Analysis Report</h1>
                    <div id="main-description" class="text-gray-600 mt-2 prose max-w-none">An interactive overview of the site annotations and raster data.</div>
                </div>
            </div>
            <button id="edit-header-btn" class="absolute top-4 right-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                Edit Header
            </button>
        </header>

        <!-- Inputs Section -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-200">
                <label for="ortho-input" class="block text-sm font-medium text-gray-700 mb-2">1. Orthophoto GeoTIFF</label>
                <input type="file" id="ortho-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept=".tif,.tiff">
            </div>
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-200">
                <label for="dsm-input" class="block text-sm font-medium text-gray-700 mb-2">2. Digital Surface Model (DSM)</label>
                <input type="file" id="dsm-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100" accept=".tif,.tiff">
            </div>
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-200">
                <label for="geojson-input" class="block text-sm font-medium text-gray-700 mb-2">3. GeoJSON Annotations</label>
                <input type="file" id="geojson-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100" accept=".geojson,.json">
            </div>
        </div>

        <!-- Main Map Section -->
        <div class="bg-white rounded-xl shadow-md mb-8 border border-gray-200">
            <div id="map" style="height: 500px;" class="rounded-t-xl"></div>
            <div class="p-4 text-sm text-gray-500 bg-gray-50 rounded-b-xl">
                <p>Interactive map showing raster layers and vector annotations. Use the layer control in the top right to toggle visibility. Measurement and drawing tools are on the left.</p>
            </div>
        </div>

        <!-- Annotations Details Section -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: Annotations List -->
            <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-md border border-gray-200">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">Annotations</h2>
                    <button id="add-annotation-info-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Add New</button>
                </div>
                <div id="annotations-list" class="space-y-3 max-h-96 overflow-y-auto">
                    <p class="text-gray-500">Upload a GeoJSON file to see annotations.</p>
                </div>
            </div>

            <!-- Right Column: Annotation Snapshot -->
            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-md border border-gray-200">
                <h2 class="text-xl font-bold mb-4">Feature Details</h2>
                <div id="snapshot-container" class="text-gray-500">
                    <p>Select an annotation from the list or map to view its details and a visual snapshot.</p>
                </div>
            </div>
        </div>

        <!-- Export Section -->
        <div class="bg-white p-6 rounded-xl shadow-md mt-8 border border-gray-200 text-center">
            <h2 class="text-xl font-bold mb-4">Export Report</h2>
            <p class="text-gray-600 mb-6">Generate a standalone ZIP file of this report. The exported version will be view-only and will contain all currently loaded data.</p>
            <button id="export-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-colors text-lg">
                Export to ZIP
            </button>
        </div>

    </div>

    <!-- Modal for notifications and inputs -->
    <div id="modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="modal-title" class="text-xl font-bold mb-4"></h3>
            <div id="modal-body" class="mb-6"></div>
            <div id="modal-footer" class="flex justify-end gap-4"></div>
        </div>
    </div>
    
    <!-- Loading Indicator -->
    <div id="loader" class="modal-overlay hidden">
        <div class="text-white text-2xl font-bold">Loading...</div>
    </div>

    <script>
        // --- INITIALIZATION ---
        let mainMap, snapshotMap;
        let geojsonLayer, selectedFeatureLayer;
        let currentSelectedFeature = null; // To track the currently selected feature object
        let rasterLayers = {};
        let geojsonCache = null;
        let orthophotoRaster = null;
        let dsmLegendControl = null;
        let quillInstance = null;

        // Cache for uploaded file data for export
        let uploadedFileData = {
            ortho: null,
            dsm: null,
            geojson: null,
            logo: null
        };

        // --- UI UTILITIES (Modal, Loader) ---
        const modal = document.getElementById('modal');
        const loader = document.getElementById('loader');

        function showLoader(text = 'Loading...') { 
            loader.querySelector('div').innerText = text;
            loader.classList.remove('hidden'); 
        }
        function hideLoader() { loader.classList.add('hidden'); }

        function showMessage(title, message) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-body').innerHTML = `<p>${message}</p>`;
            
            const footer = document.getElementById('modal-footer');
            footer.innerHTML = `<button id="modal-ok-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">OK</button>`;
            
            modal.classList.remove('hidden');
            
            document.getElementById('modal-ok-btn').onclick = () => modal.classList.add('hidden');
        }

        function showConfirm(title, message, callback) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-body').innerHTML = `<p>${message}</p>`;
            
            const footer = document.getElementById('modal-footer');
            footer.innerHTML = `
                <button id="modal-cancel-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="modal-confirm-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Confirm</button>
            `;
            
            modal.classList.remove('hidden');
            
            document.getElementById('modal-cancel-btn').onclick = () => modal.classList.add('hidden');
            document.getElementById('modal-confirm-btn').onclick = () => {
                callback();
                modal.classList.add('hidden');
            };
        }

        function showPrompt(title, fields, callback) {
            document.getElementById('modal-title').innerText = title;
            const body = document.getElementById('modal-body');
            body.innerHTML = '';
            
            let hasQuill = false;

            fields.forEach(field => {
                if (field.id.toLowerCase() === 'description') {
                    hasQuill = true;
                    body.innerHTML += `
                        <label class="block text-sm font-medium text-gray-700 mb-1">${field.label}</label>
                        <div id="quill-editor"></div>
                    `;
                } else {
                     body.innerHTML += `
                        <label for="${field.id}" class="block text-sm font-medium text-gray-700 mb-1">${field.label}</label>
                        <input type="text" id="${field.id}" value="${field.value}" class="block w-full border-gray-300 rounded-md shadow-sm mb-4">
                    `;
                }
            });

            const footer = document.getElementById('modal-footer');
            footer.innerHTML = `
                <button id="modal-cancel-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="modal-save-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Save</button>
            `;

            modal.classList.remove('hidden');
            
            if (hasQuill) {
                quillInstance = new Quill('#quill-editor', {
                    theme: 'snow',
                    modules: { toolbar: [['bold', 'italic', 'underline'], ['link'], [{ 'list': 'ordered'}, { 'list': 'bullet' }]] }
                });
                const descriptionField = fields.find(f => f.id.toLowerCase() === 'description');
                if (descriptionField && descriptionField.value) {
                    quillInstance.root.innerHTML = descriptionField.value;
                }
            }

            const closeModal = () => {
                modal.classList.add('hidden');
                quillInstance = null; // Clean up instance
            };

            document.getElementById('modal-cancel-btn').onclick = closeModal;
            document.getElementById('modal-save-btn').onclick = () => {
                const results = {};
                fields.forEach(field => {
                    if (field.id.toLowerCase() === 'description') {
                        results[field.id] = quillInstance.root.innerHTML;
                    } else {
                        results[field.id] = document.getElementById(field.id).value;
                    }
                });
                callback(results);
                closeModal();
            };
        }


        // --- MAP SETUP ---
        function initializeMaps() {
            // Initialize the main map
            mainMap = L.map('map', {
                maxZoom: 22 // Unlock max zoom level
            }).setView([29.862, -95.405], 16); 
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 22
            }).addTo(mainMap);

            // Add measure control
            const measureControl = new L.Control.Measure({
                position: 'topleft',
                primaryLengthUnit: 'meters',
                secondaryLengthUnit: 'feet',
                primaryAreaUnit: 'sqmeters',
                secondaryAreaUnit: 'acres'
            });
            measureControl.addTo(mainMap);

            // Add listener to manage selected feature visibility
            mainMap.on('overlayremove', function(e) {
                if (e.name === "Annotations" && selectedFeatureLayer) {
                    mainMap.removeLayer(selectedFeatureLayer);
                }
            });
            
            // Add Drawing Tools
            const drawnItems = new L.FeatureGroup();
            mainMap.addLayer(drawnItems);
            const drawControl = new L.Control.Draw({
                edit: { featureGroup: drawnItems, remove: false }, // Future: implement edit/delete
                draw: {
                    polygon: true,
                    polyline: true,
                    rectangle: true,
                    circle: true,
                    marker: true,
                    circlemarker: false
                }
            });
            mainMap.addControl(drawControl);

            mainMap.on(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                const geojson = layer.toGeoJSON();
                
                showPrompt('New Annotation Details', [
                    { id: 'Name', label: 'Name', value: 'New Feature' },
                    { id: 'Description', label: 'Description', value: '' }
                ], (results) => {
                    geojson.properties = results;
                    if (!geojsonCache) {
                        geojsonCache = { type: 'FeatureCollection', features: [] };
                    }
                    geojsonCache.features.push(geojson);
                    processGeoJSON(geojsonCache);
                });
            });
        }

        // --- FILE HANDLING & DATA LOADING ---

        function setupEventListeners() {
            // Header editing
            document.getElementById('logo-img').addEventListener('click', () => document.getElementById('logo-input').click());
            document.getElementById('logo-input').addEventListener('change', handleLogoUpload);
            document.getElementById('edit-header-btn').addEventListener('click', handleHeaderEdit);

            // File inputs
            document.getElementById('ortho-input').addEventListener('change', (e) => handleRasterUpload(e, 'Orthophoto'));
            document.getElementById('dsm-input').addEventListener('change', (e) => handleRasterUpload(e, 'Digital Surface Model'));
            document.getElementById('geojson-input').addEventListener('change', handleGeoJSONUpload);
            
            // Add annotation button
            document.getElementById('add-annotation-info-btn').addEventListener('click', () => {
                showMessage('Add New Annotation', 'Use the drawing tools on the left side of the map to create a new annotation. You will be prompted for details after you finish drawing.');
            });

            // Export button
            document.getElementById('export-btn').addEventListener('click', exportReport);
        }

        function handleLogoUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    document.getElementById('logo-img').src = dataUrl;
                    uploadedFileData.logo = dataUrl; // Cache for export
                };
                reader.readAsDataURL(file);
            }
        }

        function handleHeaderEdit() {
            showPrompt('Edit Header', [
                { id: 'newTitle', label: 'New Title', value: document.getElementById('main-title').innerText },
                { id: 'Description', label: 'New Description', value: document.getElementById('main-description').innerHTML }
            ], (results) => {
                if (results.newTitle !== null) document.getElementById('main-title').innerText = results.newTitle;
                if (results.Description !== null) document.getElementById('main-description').innerHTML = results.Description;
            });
        }

        function handleRasterUpload(event, layerName) {
            const file = event.target.files[0];
            if (!file) return;

            showLoader();
            const reader = new FileReader();
            reader.onload = (e) => {
                const arrayBuffer = e.target.result;
                
                // Cache the original arrayBuffer for export.
                if (layerName === 'Orthophoto') {
                    uploadedFileData.ortho = arrayBuffer;
                } else if (layerName === 'Digital Surface Model') {
                    uploadedFileData.dsm = arrayBuffer;
                }

                // Use a CLONE of the buffer for parsing to prevent the original from being "detached" by the georaster library.
                const bufferForParsing = arrayBuffer.slice(0);
                parseGeoraster(bufferForParsing).then(georaster => {
                    if (layerName === 'Orthophoto') {
                        orthophotoRaster = georaster; // Cache for snapshot
                        addRasterLayerToMap(georaster, layerName);
                    } else if (layerName === 'Digital Surface Model') {
                        addDSMLayerToMap(georaster, layerName);
                    }
                    hideLoader();
                }).catch(error => {
                    hideLoader();
                    showMessage('Raster Error', `Failed to parse the GeoTIFF file: ${file.name}. Please ensure it's a valid file. Error: ${error.message}`);
                    // Clear the cached data on error
                    if (layerName === 'Orthophoto') {
                        uploadedFileData.ortho = null;
                    } else if (layerName === 'Digital Surface Model') {
                        uploadedFileData.dsm = null;
                    }
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function addRasterLayerToMap(georaster, layerName, options = {}) {
            // Remove existing layer with the same name
            if (rasterLayers[layerName]) {
                mainMap.removeLayer(rasterLayers[layerName].layer);
                if (mainMap.layersControl) {
                    mainMap.layersControl.removeLayer(rasterLayers[layerName].layer);
                }
            }

            const defaultOptions = {
                georaster: georaster,
                opacity: 1.0,
                resolution: 256
            };

            const layer = new GeoRasterLayer({...defaultOptions, ...options});
            layer.addTo(mainMap);
            
            // Zoom to the new layer's extent
            mainMap.fitBounds(layer.getBounds());

            // Add to layer control
            if (!mainMap.layersControl) {
                mainMap.layersControl = L.control.layers(null, null, { collapsed: false }).addTo(mainMap);
            }
            mainMap.layersControl.addOverlay(layer, layerName);
            
            rasterLayers[layerName] = { layer, georaster };
        }

        function addDSMLayerToMap(georaster, layerName) {
            // Use the more robust `mins` and `maxs` arrays from the georaster object
            const min = georaster.mins[0];
            const max = georaster.maxs[0];
            
            if (min === undefined || max === undefined) {
                showMessage('DSM Error', 'Could not determine the minimum and maximum elevation values from the DSM file.');
                return;
            }
            
            // Create a color scale using chroma.js
            const colorScale = chroma.scale(['#3b82f6', '#6ee7b7', '#fde047', '#f97316', '#ef4444']).domain([min, max]);

            const pixelValuesToColorFn = (values) => {
                const value = values[0];
                if (value === georaster.noDataValue) return null; // Transparent for no-data values
                return colorScale(value).hex();
            };
            
            addRasterLayerToMap(georaster, layerName, { pixelValuesToColorFn });
            addDSMLegend(min, max, colorScale);
        }

        function addDSMLegend(min, max, colorScale) {
            if (dsmLegendControl) {
                mainMap.removeControl(dsmLegendControl);
            }

            dsmLegendControl = L.control({ position: 'bottomright' });

            dsmLegendControl.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML += '<div class="legend-title">DSM Elevation (m)</div>';
                
                const gradientDiv = L.DomUtil.create('div', 'flex');
                
                // Create gradient bar
                const gradient = L.DomUtil.create('div', 'legend-gradient');
                const gradientStops = colorScale.colors(10).join(',');
                gradient.style.background = `linear-gradient(to top, ${gradientStops})`;
                
                // Create labels
                const labels = L.DomUtil.create('div', 'legend-labels ml-1');
                const numLabels = 6;
                for (let i = 0; i < numLabels; i++) {
                    const value = min + (i / (numLabels - 1)) * (max - min);
                    const pos = 100 - (i / (numLabels - 1)) * 100;
                    const label = L.DomUtil.create('span', '', labels);
                    label.style.top = `${pos}%`;
                    label.innerHTML = `${value.toFixed(1)}`;
                }
                
                gradientDiv.appendChild(gradient);
                gradientDiv.appendChild(labels);
                div.appendChild(gradientDiv);

                return div;
            };

            dsmLegendControl.addTo(mainMap);
        }

        function handleGeoJSONUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const geojsonText = e.target.result;
                    const geojson = JSON.parse(geojsonText);
                    geojsonCache = geojson;
                    uploadedFileData.geojson = geojsonText; // Cache for export
                    processGeoJSON(geojson);
                } catch (error) {
                    showMessage("GeoJSON Error", `Error parsing GeoJSON file: ${error.message}`);
                }
            };
            reader.readAsText(file);
        }
        
        // --- GEOJSON PROCESSING ---

        function processGeoJSON(geojson) {
            // Clear previous GeoJSON layer if it exists
            if (selectedFeatureLayer) {
                mainMap.removeLayer(selectedFeatureLayer);
                selectedFeatureLayer = null;
            }
            currentSelectedFeature = null; // Clear the selected feature object

            if (geojsonLayer) {
                mainMap.removeLayer(geojsonLayer);
                if(mainMap.layersControl) mainMap.layersControl.removeLayer(geojsonLayer);
            }

            geojsonLayer = L.geoJSON(geojson, {
                style: function(feature) {
                    return {
                        color: feature.properties.Color || '#3388ff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.2
                    };
                },
                onEachFeature: function (feature, layer) {
                    // Create popup content
                    let popupContent = `<div class="font-sans"><strong>${feature.properties.Name || 'Unnamed Feature'}</strong>`;
                    if(feature.properties.Description) {
                        popupContent += `<br>${feature.properties.Description}`;
                    }
                    popupContent += `</div>`;
                    layer.bindPopup(popupContent);

                    // Add click listener
                    layer.on('click', (e) => {
                        L.DomEvent.stopPropagation(e); // Prevent map click
                        selectFeature(feature, layer);
                    });
                }
            }).addTo(mainMap);

            if(mainMap.layersControl) {
                mainMap.layersControl.addOverlay(geojsonLayer, "Annotations");
            }

            // Zoom map to the GeoJSON data
            if (geojson.features && geojson.features.length > 0) {
                mainMap.fitBounds(geojsonLayer.getBounds());
            }

            // Populate the annotations list
            populateAnnotationsList(geojson.features);
        }
        
        function populateAnnotationsList(features) {
            const list = document.getElementById('annotations-list');
            list.innerHTML = ''; // Clear existing list

            if (!features || features.length === 0) {
                list.innerHTML = '<p class="text-gray-500">No features found in the GeoJSON file.</p>';
                return;
            }

            features.forEach((feature, index) => {
                if (!feature.properties) feature.properties = {};
                const featureId = `feature-${index}`;
                feature.properties._internalId = featureId; // Assign a temporary ID

                const item = document.createElement('div');
                item.id = featureId;
                item.className = 'annotation-item p-3 rounded-lg cursor-pointer hover:bg-gray-100 transition-colors border-l-4 border-transparent';
                
                item.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="flex-grow pr-2">
                            <p class="font-semibold text-gray-800">${feature.properties.Name || 'Unnamed Feature'}</p>
                            <p class="text-sm text-gray-500 truncate">${(feature.properties.Description || 'No description').replace(/<[^>]+>/g, '')}</p>
                        </div>
                        <div class="flex-shrink-0 flex">
                            <button class="edit-annotation-btn p-2 rounded-full hover:bg-gray-200">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500 pointer-events-none" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg>
                            </button>
                            <button class="delete-annotation-btn p-2 rounded-full hover:bg-gray-200">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-red-500 pointer-events-none" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                            </button>
                        </div>
                    </div>
                `;

                item.addEventListener('click', (e) => {
                    const featureToActOn = geojsonCache.features.find(f => f.properties._internalId === feature.properties._internalId);
                    if (!featureToActOn) return;

                    if (e.target.closest('.edit-annotation-btn')) {
                        e.stopPropagation();
                        editFeatureProperties(featureToActOn);
                    } else if (e.target.closest('.delete-annotation-btn')) {
                        e.stopPropagation();
                        deleteFeature(featureToActOn);
                    } else {
                        const layer = geojsonLayer.getLayers().find(l => l.feature === featureToActOn);
                        if (layer) {
                            selectFeature(featureToActOn, layer);
                            mainMap.fitBounds(layer.getBounds(), { paddingTopLeft: [0,0], paddingBottomRight: [0,0]});
                        }
                    }
                });
                list.appendChild(item);
            });
        }

        // --- FEATURE SELECTION & SNAPSHOT ---

        function deleteFeature(featureToDelete) {
            showConfirm('Delete Annotation', `Are you sure you want to delete "${featureToDelete.properties.Name || 'this feature'}"? This action cannot be undone.`, () => {
                const idToDelete = featureToDelete.properties._internalId;
                geojsonCache.features = geojsonCache.features.filter(f => f.properties._internalId !== idToDelete);
                uploadedFileData.geojson = JSON.stringify(geojsonCache); // Update cache
                
                // If the deleted feature was the selected one, clear the snapshot panel
                if (currentSelectedFeature && currentSelectedFeature.properties._internalId === idToDelete) {
                    document.getElementById('snapshot-container').innerHTML = '<p>Select an annotation from the list or map to view its details and a visual snapshot.</p>';
                    currentSelectedFeature = null;
                }

                processGeoJSON(geojsonCache);
            });
        }

        function editFeatureProperties(feature) {
            const fields = [];
            // Create a field for every property except the internal ID
            const propKeys = Object.keys(feature.properties);
            // Ensure Name and Description are first if they exist
            if (propKeys.includes('Name')) fields.push({id: 'Name', label: 'Name', value: feature.properties['Name']});
            if (propKeys.includes('Description')) fields.push({id: 'Description', label: 'Description', value: feature.properties['Description']});
            
            for (const key of propKeys) {
                if (key !== '_internalId' && key !== 'Name' && key !== 'Description') {
                    fields.push({
                        id: key,
                        label: key,
                        value: feature.properties[key]
                    });
                }
            }

            showPrompt('Edit Feature Properties', fields, (newValues) => {
                // Update the properties in the master geojson cache
                for (const key in newValues) {
                     // Convert numeric strings back to numbers if possible
                    const originalValue = feature.properties[key];
                    let newValue = newValues[key];
                    if (typeof originalValue === 'number' && !isNaN(Number(newValue))) {
                        newValue = Number(newValue);
                    }
                    feature.properties[key] = newValue;
                }
                
                uploadedFileData.geojson = JSON.stringify(geojsonCache); // Update cache

                // Refresh the entire GeoJSON layer and list to reflect changes
                processGeoJSON(geojsonCache);

                // Find the feature's new layer object after the refresh
                const newLayer = geojsonLayer.getLayers().find(l => l.feature.properties._internalId === feature.properties._internalId);
                if (newLayer) {
                    // Reselect the feature to update the map highlight and snapshot panel
                    selectFeature(feature, newLayer);
                }
            });
        }

        function selectFeature(feature, layer) {
            currentSelectedFeature = feature; // Set the globally tracked selected feature
            
            // 1. Highlight feature on map
            if (selectedFeatureLayer) {
                mainMap.removeLayer(selectedFeatureLayer);
            }
            selectedFeatureLayer = L.geoJSON(feature, {
                style: {
                    color: '#e11d48', // A bright color for selection
                    weight: 4,
                    opacity: 1,
                    fillOpacity: 0.5,
                    fillColor: '#fecdd3'
                }
            }).addTo(mainMap);
            selectedFeatureLayer.bringToFront();

            // 2. Highlight feature in list
            document.querySelectorAll('.annotation-item').forEach(item => item.classList.remove('selected'));
            const listItem = document.getElementById(feature.properties._internalId);
            if(listItem) {
                listItem.classList.add('selected');
                listItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // 3. Update and display snapshot
            updateSnapshot(feature);
        }

        function updateSnapshot(feature) {
            const container = document.getElementById('snapshot-container');
            container.innerHTML = ''; // Clear previous content

            // Create details section
            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'mb-4';
            let detailsHtml = `<h3 class="text-lg font-bold text-gray-900">${feature.properties.Name || ''}</h3>`;
            
            // Render HTML from description
            const descriptionContainer = document.createElement('div');
            descriptionContainer.className = 'text-gray-600 prose max-w-none';
            descriptionContainer.innerHTML = feature.properties.Description || '';
            
            detailsDiv.innerHTML = detailsHtml;
            detailsDiv.appendChild(descriptionContainer);
            detailsDiv.innerHTML += '<hr class="my-3">';
            
            // Display all properties
            let propsHtml = '<div class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2 text-sm">';
            for(const key in feature.properties) {
                if(key !== 'Name' && key !== 'Description' && key !== '_internalId' && key !== 'Color') {
                    const value = feature.properties[key];
                    propsHtml += `<div><strong class="break-all">${key}:</strong></div><div>${typeof value === 'object' ? JSON.stringify(value) : value}</div>`;
                }
            }
            propsHtml += '</div>';
            detailsDiv.innerHTML += propsHtml;

             // Add Edit button
            detailsDiv.innerHTML += `
                <div class="mt-6 text-right">
                    <button id="edit-snapshot-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Edit Details</button>
                </div>
            `;
            container.appendChild(detailsDiv);
            
            document.getElementById('edit-snapshot-btn').addEventListener('click', () => editFeatureProperties(feature));


            // Create map snapshot section
            const mapDiv = document.createElement('div');
            mapDiv.id = 'snapshot-map';
            mapDiv.style.height = '300px';
            mapDiv.className = 'rounded-lg border border-gray-300 mt-4';
            container.appendChild(mapDiv);

            // Destroy previous snapshot map instance if it exists
            if (snapshotMap) {
                snapshotMap.remove();
            }

            // Get bounding box of the feature
            const bbox = turf.bbox(feature); // [minLon, minLat, maxLon, maxLat]
            const bounds = [[bbox[1], bbox[0]], [bbox[3], bbox[2]]]; // Leaflet format: [[lat, lon], [lat, lon]]
            
            // Initialize new snapshot map
            snapshotMap = L.map('snapshot-map', {
                zoomControl: false,
                attributionControl: false,
                scrollWheelZoom: false,
                doubleClickZoom: false,
                dragging: false,
            }).fitBounds(bounds, { padding: [10, 10] });

            // Add orthophoto layer if available
            if (orthophotoRaster) {
                 new GeoRasterLayer({
                    georaster: orthophotoRaster,
                    opacity: 1,
                    resolution: 128 // Lower res for performance
                }).addTo(snapshotMap);
            } else {
                // Fallback to OSM if no orthophoto
                 L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(snapshotMap);
                 const warning = L.control({position: 'topleft'});
                 warning.onAdd = function(map) {
                     var div = L.DomUtil.create('div', 'p-2 bg-yellow-200 text-yellow-800 text-xs rounded-md');
                     div.innerHTML = 'Orthophoto not loaded';
                     return div;
                 };
                 warning.addTo(snapshotMap);
            }

            // Draw the feature geometry on the snapshot map
            L.geoJSON(feature, {
                style: {
                    color: '#e11d48',
                    weight: 3,
                    fill: false
                }
            }).addTo(snapshotMap);
        }

        // --- EXPORT FUNCTIONALITY ---
        async function exportReport() {
            showLoader('Generating Report...');
            try {
                const zip = new JSZip();
                const dataFolder = zip.folder("data");

                // 1. Add data files to zip
                if (uploadedFileData.ortho) {
                    dataFolder.file("ortho.tif", uploadedFileData.ortho);
                }
                if (uploadedFileData.dsm) {
                    dataFolder.file("dsm.tif", uploadedFileData.dsm);
                }
                if (uploadedFileData.geojson) {
                    dataFolder.file("annotations.geojson", uploadedFileData.geojson);
                }
                if (uploadedFileData.logo && uploadedFileData.logo.startsWith('data:')) {
                    // Convert data URL to blob
                    const response = await fetch(uploadedFileData.logo);
                    const blob = await response.blob();
                    dataFolder.file("logo." + (blob.type.split('/')[1] || 'png'), blob);
                }
                
                // 2. Create the view-only HTML
                const viewHTML = createViewHTML();
                zip.file("index.html", viewHTML);

                // 3. Generate and download the zip
                const content = await zip.generateAsync({type:"blob"});
                const link = document.createElement("a");
                link.href = URL.createObjectURL(content);
                link.download = "Site-Report.zip";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

            } catch (error) {
                console.error("Failed to export report:", error);
                showMessage("Export Error", "An error occurred while generating the report. Please try again.");
            } finally {
                hideLoader();
            }
        }

        function createViewHTML() {
            // Clone the current document's body to easily get the header/content structure
            const bodyClone = document.body.cloneNode(true);
            
            // Get current header content
            const logoSrc = uploadedFileData.logo ? `data/logo.${uploadedFileData.logo.split(';')[0].split('/')[1]}` : document.getElementById('logo-img').src;
            const mainTitle = document.getElementById('main-title').innerText;
            const mainDescription = document.getElementById('main-description').innerHTML;
            
            // Get current annotations list (without controls)
            const annotationsList = document.getElementById('annotations-list').cloneNode(true);
            annotationsList.querySelectorAll('.edit-annotation-btn, .delete-annotation-btn').forEach(btn => btn.remove());

            // The script for the view-only page
            const viewScript = `
                let mainMap, snapshotMap, geojsonLayer, selectedFeatureLayer, orthophotoRaster, dsmLegendControl;
                let rasterLayers = {};
                let geojsonCache = null;

                function showLoader(text = 'Loading...') { document.getElementById('loader').classList.remove('hidden'); }
                function hideLoader() { document.getElementById('loader').classList.add('hidden'); }

                // Paste in required functions from the main script, but modified for view-only
                ${initializeMaps.toString().replace('measureControl.addTo(mainMap);', '').replace('mainMap.addControl(drawControl);', '').replace(/mainMap\.on\(L\.Draw\.Event\.CREATED, .*?\);/s, '')}
                ${addRasterLayerToMap.toString()}
                ${addDSMLayerToMap.toString()}
                ${addDSMLegend.toString()}
                ${processGeoJSON.toString().replace('layer.on(\'click\'', 'layer.on(\'click\'')}
                ${populateAnnotationsList.toString().replace(/<button class="edit-annotation-btn.*?<\/button>/gs, '').replace(/<button class="delete-annotation-btn.*?<\/button>/gs, '')}
                ${selectFeature.toString()}
                ${updateSnapshot.toString().replace(/<div class="mt-6 text-right">.*?<\/div>/s, '')}

                async function loadExportedData() {
                    showLoader();
                    const dataExists = { ortho: false, dsm: false, geojson: false };

                    const orthoPromise = fetch('data/ortho.tif')
                        .then(res => { if (!res.ok) throw new Error('not found'); dataExists.ortho = true; return res.arrayBuffer(); })
                        .then(buffer => parseGeoraster(buffer).then(georaster => {
                            orthophotoRaster = georaster;
                            addRasterLayerToMap(georaster, 'Orthophoto');
                        }))
                        .catch(err => console.log("Exported orthophoto not found or failed to load."));

                    const dsmPromise = fetch('data/dsm.tif')
                        .then(res => { if (!res.ok) throw new Error('not found'); dataExists.dsm = true; return res.arrayBuffer(); })
                        .then(buffer => parseGeoraster(buffer).then(georaster => addDSMLayerToMap(georaster, 'Digital Surface Model')))
                        .catch(err => console.log("Exported DSM not found or failed to load."));

                    const geojsonPromise = fetch('data/annotations.geojson')
                        .then(res => { if (!res.ok) throw new Error('not found'); dataExists.geojson = true; return res.json(); })
                        .then(json => {
                            geojsonCache = json;
                            processGeoJSON(json);
                        })
                        .catch(err => {
                            document.getElementById('annotations-list').innerHTML = '<p class="text-gray-500">No annotations were included in this export.</p>';
                        });
                    
                    await Promise.allSettled([orthoPromise, dsmPromise, geojsonPromise]);

                    if (!dataExists.ortho && !dataExists.dsm && !dataExists.geojson) {
                       mainMap.setView([29.862, -95.405], 5); // Zoom out if no data loaded
                    }
                    hideLoader();
                }

                document.addEventListener('DOMContentLoaded', () => {
                    initializeMaps();
                    loadExportedData();
                });
            `;

            // Assemble the final HTML string
            return `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>${mainTitle} - Report</title>
                    <script src="https://cdn.tailwindcss.com"><\/script>
                    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
                    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"><\/script>
                    <script src="https://unpkg.com/georaster"><\/script>
                    <script src="https://unpkg.com/georaster-layer-for-leaflet"><\/script>
                    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"><\/script>
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"><\/script>
                    <style>${document.querySelector('style').innerHTML}<\/style>
                </head>
                <body class="bg-gray-100 text-gray-800">
                    <div class="container mx-auto p-4 md:p-8">
                        <header class="bg-white p-6 rounded-xl shadow-md mb-8 border border-gray-200">
                            <div class="flex flex-col items-center gap-4 text-center">
                                <img id="logo-img" src="${logoSrc}" alt="Logo" class="h-20 w-20 rounded-full object-cover mb-2" onerror="this.style.display='none'">
                                <div>
                                    <h1 id="main-title" class="text-3xl font-bold text-gray-900">${mainTitle}</h1>
                                    <div id="main-description" class="text-gray-600 mt-2 prose max-w-none">${mainDescription}</div>
                                </div>
                            </div>
                        </header>
                        <div class="bg-white rounded-xl shadow-md mb-8 border border-gray-200">
                            <div id="map" style="height: 500px;" class="rounded-t-xl"></div>
                            <div class="p-4 text-sm text-gray-500 bg-gray-50 rounded-b-xl">
                                <p>This is a view-only report. Pan and zoom on the map, and click features to view details.</p>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                            <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-md border border-gray-200">
                                <h2 class="text-xl font-bold mb-4">Annotations</h2>
                                <div id="annotations-list" class="space-y-3 max-h-96 overflow-y-auto">${annotationsList.innerHTML}</div>
                            </div>
                            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-md border border-gray-200">
                                <h2 class="text-xl font-bold mb-4">Feature Details</h2>
                                <div id="snapshot-container" class="text-gray-500">
                                    <p>Select an annotation from the list or map to view its details and a visual snapshot.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="loader" class="modal-overlay"><div class="text-white text-2xl font-bold">Loading...</div></div>
                    <script>${viewScript}<\/script>
                </body>
                </html>
            `;
        }


        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeMaps();
            setupEventListeners();
        });
    </script>

</body>
</html>

