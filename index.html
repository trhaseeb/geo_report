<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Geospatial Data Viewer</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js for mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Core dependencies for GeoTIFF parsing and display -->
    <script src="https://unpkg.com/georaster"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet"></script>
    
    <!-- Turf.js for geospatial analysis (e.g., bounding box) -->
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>

    <!-- Leaflet Plugins -->
    <!-- Leaflet.Measure for measurement tools -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure@3.1.0/dist/leaflet-measure.css">
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure@3.1.0/dist/leaflet-measure.min.js"></script>

    <!-- Leaflet.draw for drawing tools -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <!-- Quill WYSIWYG Editor -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

    <!-- Chroma.js for color scales -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>

    <!-- JSZip for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        /* Use Inter font from Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; }
        .leaflet-popup-content-wrapper { border-radius: 8px; }
        .leaflet-control-layers { border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .legend-item.selected { background-color: #e0f2fe !important; }
        #snapshot-map { pointer-events: none; }
        .dsm-legend { background-color: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); line-height: 1.2; }
        .dsm-legend-title { font-weight: bold; margin-bottom: 5px; }
        .dsm-legend-gradient { height: 150px; width: 20px; border: 1px solid #ccc; }
        .dsm-legend-labels { position: relative; height: 150px; width: 40px; }
        .dsm-legend-labels span { position: absolute; right: 0; transform: translateY(-50%); font-size: 10px; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 10000; transition: opacity 0.3s ease; }
        .modal-content { background: white; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 90%; max-width: 600px; max-height: 90vh; overflow-y: auto; }
        .hidden { display: none; }
        #quill-editor { height: 200px; margin-bottom: 1rem; }
        #category-manager-panel { position: fixed; top: 100px; left: -450px; width: 400px; max-height: calc(100vh - 120px); background: white; border-radius: 0 15px 15px 0; box-shadow: 5px 0 15px rgba(0,0,0,0.2); z-index: 1001; transition: left 0.3s ease-in-out; display: flex; flex-direction: column; }
        #category-manager-panel.open { left: 10px; }
        .panel-header { padding: 1rem; border-bottom: 1px solid #e5e7eb; font-size: 1.25rem; font-weight: bold; display: flex; justify-content: space-between; align-items: center; }
        .panel-content { padding: 1.5rem; overflow-y: auto; flex-grow: 1; }
        .panel-footer { padding: 1rem; border-top: 1px solid #e5e7eb; display: flex; justify-content: flex-end; }
        .category-item { border: 1px solid #d1d5db; border-radius: 0.5rem; margin-bottom: 1rem; }
        .category-item-header { padding: 0.75rem; background-color: #f9fafb; border-bottom: 1px solid #d1d5db; display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .category-item-body { padding: 1rem; display: none; }
        .category-item.open .category-item-body { display: block; }
        .style-section h4 { font-weight: 600; margin-top: 1rem; margin-bottom: 0.75rem; border-bottom: 1px solid #f3f4f6; padding-bottom: 0.5rem; }
        .style-section:first-child h4 { margin-top: 0; }
        .style-control { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; align-items: center; margin-bottom: 0.75rem; }
        .style-control label { font-size: 0.875rem; color: #4b5563; }
        .style-control input, .style-control select { width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; }
        .style-control input[type="color"] { padding: 0; height: 2.5rem; cursor: pointer; border: none; background: none; }
        .legend-category-header { display: flex; align-items: center; justify-content: space-between; padding: 8px; cursor: pointer; background-color: #f3f4f6; border-radius: 4px; }
        .legend-category-header:hover { background-color: #e5e7eb; }
        .legend-item { display: flex; align-items: center; padding: 6px 8px 6px 24px; cursor: pointer; border-radius: 4px; }
        .legend-item:hover { background-color: #f9fafb; }
        .legend-swatch { width: 16px; height: 16px; margin-right: 8px; border: 1px solid #ccc; flex-shrink: 0; }
        .legend-item-list { display: none; }
        .legend-category.open .legend-item-list { display: block; }
        .leaflet-tooltip-label { background: white; border: 1px solid #9ca3af; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-weight: bold; padding: 4px 8px; white-space: nowrap; }
        .custom-svg-icon { background: transparent; border: none; }
        .custom-svg-icon svg { width: 100%; height: 100%; display: block; }
        .leaflet-square-icon { background: transparent; border: none; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        
        <!-- Header Section -->
        <header class="bg-white p-6 rounded-xl shadow-md mb-8 border border-gray-200 relative">
            <div class="flex flex-col md:flex-row items-center gap-6 text-center md:text-left">
                <img id="logo-img" src="https://placehold.co/80x80/e2e8f0/334155?text=Logo" alt="Logo" class="h-20 w-20 rounded-full object-cover cursor-pointer mb-2 md:mb-0">
                <input type="file" id="logo-input" class="hidden" accept="image/*">
                <div>
                    <h1 id="main-title" class="text-3xl font-bold text-gray-900">Site Analysis Report</h1>
                    <div id="main-description" class="text-gray-600 mt-2 prose max-w-none">An interactive overview of the site annotations and raster data.</div>
                </div>
            </div>
             <div class="absolute top-4 right-4 flex flex-col gap-2">
                <button id="edit-header-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">Edit Header</button>
            </div>
        </header>

        <!-- Inputs Section -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-200">
                <label for="ortho-input" class="block text-sm font-medium text-gray-700 mb-2">1. Orthophoto GeoTIFF</label>
                <input type="file" id="ortho-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" accept=".tif,.tiff">
            </div>
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-200">
                <label for="dsm-input" class="block text-sm font-medium text-gray-700 mb-2">2. Digital Surface Model (DSM)</label>
                <input type="file" id="dsm-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100" accept=".tif,.tiff">
            </div>
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-200">
                <label for="geojson-input" class="block text-sm font-medium text-gray-700 mb-2">3. GeoJSON Annotations</label>
                <input type="file" id="geojson-input" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100" accept=".geojson,.json">
            </div>
        </div>

        <!-- Tools & Legend Controls Section -->
        <div class="bg-white p-4 rounded-xl shadow-md mb-8 border border-gray-200 flex items-center gap-4">
            <h2 class="text-xl font-bold text-gray-800">Tools & Legend</h2>
            <div class="flex-grow"></div>
            <button id="manage-categories-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">Manage Categories</button>
            <button id="toggle-labels-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">Show Labels</button>
        </div>

        <!-- Main Map Section -->
        <div class="bg-white rounded-xl shadow-md mb-8 border border-gray-200">
            <div id="map" style="height: 600px;" class="rounded-t-xl"></div>
            <div class="p-4 text-sm text-gray-500 bg-gray-50 rounded-b-xl">
                <p>Interactive map showing raster layers and vector annotations. Use the layer control in the top right to toggle visibility. Measurement and drawing tools are on the left.</p>
            </div>
        </div>

        <!-- Legend & Details Section -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-8">
            <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-md border border-gray-200">
                <h2 class="text-xl font-bold mb-4">Legend</h2>
                <div id="legend-content" class="space-y-2 max-h-[60vh] overflow-y-auto">
                    <p class="text-gray-500 text-sm">No categories defined. Use the Category Manager to create them.</p>
                </div>
            </div>
            <div class="lg:col-span-2 bg-white p-6 rounded-xl shadow-md border border-gray-200">
                <h2 class="text-xl font-bold mb-4">Feature Details</h2>
                <div id="snapshot-container" class="text-gray-500">
                    <p>Select an annotation from the legend or map to view its details and a visual snapshot.</p>
                </div>
            </div>
        </div>

        <!-- Export Section -->
        <div class="bg-white p-6 rounded-xl shadow-md mt-8 border border-gray-200 text-center">
            <h2 class="text-xl font-bold mb-4">Export Report</h2>
            <p class="text-gray-600 mb-6">Generate a standalone ZIP file of this report. The exported version will be view-only and will contain all currently loaded data.</p>
            <button id="export-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-colors text-lg">
                Export to ZIP
            </button>
        </div>
    </div>

    <!-- Modal for notifications and inputs -->
    <div id="modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="modal-title" class="text-xl font-bold mb-4"></h3>
            <div id="modal-body" class="mb-6"></div>
            <div id="modal-footer" class="flex justify-end gap-4"></div>
        </div>
    </div>
    
    <!-- Loading Indicator -->
    <div id="loader" class="modal-overlay hidden">
        <div class="text-white text-2xl font-bold">Loading...</div>
    </div>

    <!-- Category Manager Panel -->
    <div id="category-manager-panel">
        <div class="panel-header">
            <span>Category Manager</span>
            <button id="close-category-manager-btn" class="p-1 rounded-full text-2xl leading-none hover:bg-gray-200">&times;</button>
        </div>
        <div id="category-manager-content" class="panel-content">
            <!-- Category items will be dynamically inserted here -->
        </div>
        <div class="panel-footer">
            <button id="add-category-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">Add New Category</button>
        </div>
    </div>

    <script>
        // --- REBUILT APPLICATION SCRIPT ---

        // --- 1. GLOBAL STATE & INITIALIZATION ---
        const appState = {
            map: null,
            snapshotMap: null,
            layersControl: null,
            geojsonLayer: null,
            dsmLegendControl: null,
            labelsVisible: false,
            data: {
                ortho: { georaster: null, fileBuffer: null, layer: null },
                dsm: { georaster: null, fileBuffer: null, layer: null },
                geojson: { data: null, fileContent: null },
                logo: null,
                categories: {},
            },
            featureIdToLayerMap: new Map(),
        };

        // --- 2. UI UTILITIES (Modal, Loader, etc.) ---
        const modal = document.getElementById('modal');
        const loader = document.getElementById('loader');
        const categoryManagerPanel = document.getElementById('category-manager-panel');

        function showLoader(text = 'Loading...') { loader.querySelector('div').innerText = text; loader.classList.remove('hidden'); }
        function hideLoader() { loader.classList.add('hidden'); }
        function showMessage(title, message) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-body').innerHTML = `<p>${message}</p>`;
            document.getElementById('modal-footer').innerHTML = `<button id="modal-ok-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">OK</button>`;
            modal.classList.remove('hidden');
            document.getElementById('modal-ok-btn').onclick = () => modal.classList.add('hidden');
        }
        function showConfirm(title, message, callback) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-body').innerHTML = `<p>${message}</p>`;
            document.getElementById('modal-footer').innerHTML = `
                <button id="modal-cancel-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="modal-confirm-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Confirm</button>
            `;
            modal.classList.remove('hidden');
            document.getElementById('modal-cancel-btn').onclick = () => modal.classList.add('hidden');
            document.getElementById('modal-confirm-btn').onclick = () => { callback(); modal.classList.add('hidden'); };
        }
        function showPrompt(title, fields, callback) {
            document.getElementById('modal-title').innerText = title;
            const body = document.getElementById('modal-body');
            body.innerHTML = '';
            let quillInstance = null;
            const hasQuill = fields.some(f => f.type === 'quill');

            fields.forEach(field => {
                if (field.type === 'quill') {
                    body.innerHTML += `<label class="block text-sm font-medium text-gray-700 mb-1">${field.label}</label><div id="quill-editor"></div>`;
                } else if (field.type === 'select') {
                    const options = field.options.map(opt => `<option value="${opt.value}" ${opt.value === field.value ? 'selected' : ''}>${opt.label}</option>`).join('');
                    body.innerHTML += `<label for="${field.id}" class="block text-sm font-medium text-gray-700 mb-1">${field.label}</label><select id="${field.id}" class="block w-full border-gray-300 rounded-md shadow-sm mb-4 p-2 border">${options}</select>`;
                } else {
                    body.innerHTML += `<label for="${field.id}" class="block text-sm font-medium text-gray-700 mb-1">${field.label}</label><input type="text" id="${field.id}" value="${field.value}" class="block w-full border-gray-300 rounded-md shadow-sm mb-4 p-2 border">`;
                }
            });

            document.getElementById('modal-footer').innerHTML = `
                <button id="modal-cancel-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="modal-save-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Save</button>
            `;
            modal.classList.remove('hidden');
            
            if (hasQuill) {
                quillInstance = new Quill('#quill-editor', { theme: 'snow', modules: { toolbar: [['bold', 'italic', 'underline'], ['link'], [{ 'list': 'ordered'}, { 'list': 'bullet' }]] } });
                const quillField = fields.find(f => f.type === 'quill');
                if (quillField && quillField.value) quillInstance.root.innerHTML = quillField.value;
            }

            const closeModal = () => modal.classList.add('hidden');
            document.getElementById('modal-cancel-btn').onclick = closeModal;
            document.getElementById('modal-save-btn').onclick = () => {
                const results = {};
                fields.forEach(field => {
                    results[field.id] = (field.type === 'quill') ? quillInstance.root.innerHTML : document.getElementById(field.id).value;
                });
                callback(results);
                closeModal();
            };
        }

        // --- 3. MAP INITIALIZATION & CONTROLS ---
        function initializeMap() {
            appState.map = L.map('map', { maxZoom: 22 }).setView([29.7604, -95.3698], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors', maxZoom: 22, crossOrigin: true }).addTo(appState.map);
            appState.layersControl = L.control.layers(null, {}, { collapsed: false }).addTo(appState.map);
            const measureControl = new L.Control.Measure({ position: 'topleft', primaryLengthUnit: 'feet', secondaryLengthUnit: 'meters', primaryAreaUnit: 'acres', secondaryAreaUnit: 'sqmeters' });
            measureControl.addTo(appState.map);
            const drawnItems = new L.FeatureGroup();
            appState.map.addLayer(drawnItems);
            const drawControl = new L.Control.Draw({ edit: false, draw: { polygon: true, polyline: true, rectangle: true, circle: false, marker: true, circlemarker: false } });
            appState.map.addControl(drawControl);
            appState.map.on(L.Draw.Event.CREATED, handleDrawNewFeature);
        }

        // --- 4. DATA HANDLING & PROCESSING ---
        function readFile(file, readAs) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                if (readAs === 'arrayBuffer') reader.readAsArrayBuffer(file);
                else if (readAs === 'text') reader.readAsText(file);
                else if (readAs === 'dataURL') reader.readAsDataURL(file);
            });
        }
        async function handleRasterUpload(event, type) {
            const file = event.target.files[0];
            if (!file) return;
            showLoader(`Loading ${type.toUpperCase()}...`);
            try {
                const fileBuffer = await readFile(file, 'arrayBuffer');
                const georaster = await parseGeoraster(fileBuffer);
                appState.data[type] = { georaster, fileBuffer, layer: appState.data[type].layer };
                addOrUpdateRasterLayer(type);
            } catch (error) {
                console.error(`Error loading ${type}:`, error);
                showMessage('File Error', `Failed to load or parse ${file.name}. Please ensure it's a valid GeoTIFF.`);
                appState.data[type] = { georaster: null, fileBuffer: null, layer: null };
            } finally { hideLoader(); }
        }
        async function handleGeoJSONUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            showLoader('Loading GeoJSON...');
            try {
                const fileContent = await readFile(file, 'text');
                const geojson = JSON.parse(fileContent);

                // Merge categories from file, preserving existing ones
                if (geojson.properties && geojson.properties.categories) {
                    Object.assign(appState.data.categories, geojson.properties.categories);
                    renderCategoryManager();
                }

                if (geojson.features) {
                    let defaultCategoryName = Object.keys(appState.data.categories)[0];
                    // If no categories exist at all, create a default one
                    if (!defaultCategoryName) {
                        defaultCategoryName = "Imported";
                        appState.data.categories[defaultCategoryName] = { styles: { point: { color: '#808080', size: 16, shape: 'circle', svg: '' }, line: { color: '#808080', weight: 3, dashArray: 'solid' }, polygon: { fillColor: '#808080', fillOpacity: 0.2, color: '#808080', weight: 3, dashArray: 'solid' } } };
                        renderCategoryManager();
                    }

                    geojson.features.forEach((feature, index) => {
                        if (!feature.properties) feature.properties = {};
                        feature.properties._internalId = `feature-${Date.now()}-${index}`;
                        if (!feature.properties.category || !appState.data.categories[feature.properties.category]) {
                            feature.properties.category = defaultCategoryName;
                        }
                    });
                }

                appState.data.geojson = { data: geojson, fileContent };
                renderGeoJSONLayer();
            } catch (error) {
                console.error('GeoJSON Error:', error);
                showMessage('File Error', `Failed to parse ${file.name}. Please ensure it's a valid GeoJSON file.`);
                appState.data.geojson = { data: null, fileContent: null };
            } finally { hideLoader(); }
        }

        // --- 5. MAP RENDERING & UPDATES ---
        function addOrUpdateRasterLayer(type) {
            const data = appState.data[type];
            if (!data.georaster) return;
            if (data.layer) { appState.layersControl.removeLayer(data.layer); appState.map.removeLayer(data.layer); }
            const layerOptions = { georaster: data.georaster, opacity: 1.0, resolution: 256 };
            const layerName = type === 'ortho' ? 'Orthophoto' : 'Digital Surface Model';
            if (type === 'dsm') {
                const { mins, maxs, noDataValue } = data.georaster;
                if (mins && maxs && isFinite(mins[0]) && isFinite(maxs[0])) {
                    const colorScale = chroma.scale(['#3b82f6', '#6ee7b7', '#fde047', '#f97316', '#ef4444']).domain([mins[0], maxs[0]]);
                    layerOptions.pixelValuesToColorFn = values => (values[0] === noDataValue) ? null : colorScale(values[0]).hex();
                    renderDSMLegend(mins[0], maxs[0], colorScale);
                } else { showMessage('DSM Info', 'Could not determine elevation range for DSM styling.'); }
            }
            data.layer = new GeoRasterLayer(layerOptions);
            appState.layersControl.addOverlay(data.layer, layerName);
            data.layer.addTo(appState.map);
            appState.map.fitBounds(data.layer.getBounds());
        }
        function renderDSMLegend(min, max, colorScale) {
            if (appState.dsmLegendControl) appState.map.removeControl(appState.dsmLegendControl);
            appState.dsmLegendControl = L.control({ position: 'bottomright' });
            appState.dsmLegendControl.onAdd = () => {
                const div = L.DomUtil.create('div', 'dsm-legend');
                const gradientStops = colorScale.colors(10).join(',');
                const gradientStyle = `linear-gradient(to top, ${gradientStops})`;
                div.innerHTML = `<div class="dsm-legend-title">DSM Elevation (m)</div><div class="flex"><div class="dsm-legend-gradient" style="background: ${gradientStyle};"></div><div class="dsm-legend-labels ml-1">${[...Array(6)].map((_, i) => { const value = min + (i / 5) * (max - min); const pos = 100 - (i / 5) * 100; return `<span style="top: ${pos}%;">${value.toFixed(1)}</span>`; }).join('')}</div></div>`;
                return div;
            };
            appState.dsmLegendControl.addTo(appState.map);
        }
        function renderGeoJSONLayer() {
            if (appState.geojsonLayer) { appState.layersControl.removeLayer(appState.geojsonLayer); appState.map.removeLayer(appState.geojsonLayer); }
            appState.featureIdToLayerMap.clear();
            const geojson = appState.data.geojson.data;
            if (!geojson || !geojson.features) { renderLegend(); return; }

            appState.geojsonLayer = L.geoJSON(geojson, {
                style: feature => getStyleForFeature(feature),
                onEachFeature: (feature, layer) => {
                    appState.featureIdToLayerMap.set(feature.properties._internalId, layer);
                    bindFeatureInteractions(feature, layer);
                },
                pointToLayer: (feature, latlng) => createPointMarker(feature, latlng)
            });
            appState.layersControl.addOverlay(appState.geojsonLayer, "Annotations");
            appState.geojsonLayer.addTo(appState.map);
            if (geojson.features.length > 0) { const bounds = appState.geojsonLayer.getBounds(); if (bounds.isValid()) appState.map.fitBounds(bounds); }
            renderLegend();
            toggleLabels(appState.labelsVisible, true);
        }

        // --- 6. FEATURE & CATEGORY/SYMBOLOGY MANAGEMENT ---
        function getStyleForFeature(feature) {
            const categoryName = feature.properties.category;
            const category = appState.data.categories[categoryName];
            if (!category) return { color: '#808080', weight: 2 }; 
            const geomType = feature.geometry.type;
            if (geomType.includes('Polygon')) return category.styles.polygon;
            if (geomType.includes('LineString')) return category.styles.line;
            if (geomType.includes('Point')) return category.styles.point;
            return { color: '#808080', weight: 2 };
        }
        function createPointMarker(feature, latlng) {
            const style = getStyleForFeature(feature);
            const size = style.size || 16;
            const anchor = size / 2;
            if (style.shape === 'svg' && style.svg && style.svg.trim()) {
                const iconHtml = style.svg.replace(/currentColor/g, style.color);
                return L.marker(latlng, { icon: L.divIcon({ html: iconHtml, className: 'custom-svg-icon', iconSize: [size, size], iconAnchor: [anchor, anchor] }) });
            }
            if (style.shape === 'square') {
                return L.marker(latlng, { icon: L.divIcon({ html: `<div style="background-color: ${style.color}; width: ${size}px; height: ${size}px; border-radius: 2px;"></div>`, className: 'leaflet-square-icon', iconSize: [size, size], iconAnchor: [anchor, anchor] }) });
            }
            const circleMarkerStyle = { ...style, radius: size / 2, fillColor: style.color, color: "#000", weight: 1, fillOpacity: 0.8 };
            delete circleMarkerStyle.size;
            return L.circleMarker(latlng, circleMarkerStyle);
        }
        function handleDrawNewFeature(e) {
            const categoryOptions = Object.keys(appState.data.categories).map(name => ({ label: name, value: name }));
            if (categoryOptions.length === 0) {
                showMessage('No Categories', 'Please create a category first using the "Manage Categories" button before drawing a new feature.');
                return;
            }
            const newFeature = e.layer.toGeoJSON();
            showPrompt('New Annotation Details', [
                { id: 'Name', label: 'Name', value: 'New Feature', type: 'text' },
                { id: 'Description', label: 'Description', value: '', type: 'quill' },
                { id: 'category', label: 'Category', value: categoryOptions[0].value, type: 'select', options: categoryOptions }
            ], (results) => {
                newFeature.properties = results;
                newFeature.properties._internalId = `feature-${Date.now()}-${Math.random()}`;
                if (!appState.data.geojson.data) appState.data.geojson.data = { type: 'FeatureCollection', features: [] };
                appState.data.geojson.data.features.push(newFeature);
                renderGeoJSONLayer();
                selectFeature(newFeature.properties._internalId);
            });
        }
        function bindFeatureInteractions(feature, layer) {
            const container = L.DomUtil.create('div', 'font-sans max-w-xs');
            container.innerHTML = `<strong class="text-base">${feature.properties.Name || 'Unnamed Feature'}</strong><div class="text-sm mt-1 prose max-w-none">${feature.properties.Description || ''}</div>`;
            const buttonContainer = L.DomUtil.create('div', 'mt-2 flex gap-2', container);
            const editButton = L.DomUtil.create('button', 'bg-blue-500 hover:bg-blue-600 text-white text-xs py-1 px-2 rounded', buttonContainer);
            editButton.innerText = 'Edit';
            const deleteButton = L.DomUtil.create('button', 'bg-red-500 hover:bg-red-600 text-white text-xs py-1 px-2 rounded', buttonContainer);
            deleteButton.innerText = 'Delete';
            
            L.DomEvent.on(editButton, 'click', (e) => { L.DomEvent.stop(e); editFeatureProperties(feature); });
            L.DomEvent.on(deleteButton, 'click', (e) => { L.DomEvent.stop(e); deleteFeature(feature); });
            
            layer.bindPopup(container);
            layer.on('click', (e) => { L.DomEvent.stopPropagation(e); selectFeature(feature.properties._internalId); });
            if (feature.properties.Name) {
                layer.bindTooltip(feature.properties.Name, { permanent: false, direction: 'top', offset: [0, -10], className: 'leaflet-tooltip-label' });
            }
        }
        function selectFeature(featureId) {
            const feature = appState.data.geojson.data.features.find(f => f.properties._internalId === featureId);
            if (!feature) return;
            const layer = appState.featureIdToLayerMap.get(featureId);
            if (layer) {
                if (layer.getBounds) { appState.map.fitBounds(layer.getBounds(), { paddingTopLeft: [350, 20], paddingBottomRight: [20, 20], maxZoom: 19 }); }
                else if (layer.getLatLng) { appState.map.setView(layer.getLatLng(), Math.max(appState.map.getZoom(), 18)); }
                layer.openPopup();
            }
            document.querySelectorAll('.legend-item').forEach(item => item.classList.remove('selected'));
            const listItem = document.querySelector(`.legend-item[data-feature-id="${featureId}"]`);
            if (listItem) { listItem.classList.add('selected'); listItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
            renderSnapshot(feature);
        }
        function editFeatureProperties(feature) {
            appState.map.closePopup();
            const categoryOptions = Object.keys(appState.data.categories).map(name => ({ label: name, value: name }));
            showPrompt('Edit Annotation', [
                { id: 'Name', label: 'Name', value: feature.properties.Name || '', type: 'text' },
                { id: 'Description', label: 'Description', value: feature.properties.Description || '', type: 'quill' },
                { id: 'category', label: 'Category', value: feature.properties.category, type: 'select', options: categoryOptions }
            ], (results) => {
                feature.properties.Name = results.Name;
                feature.properties.Description = results.Description;
                feature.properties.category = results.category;
                renderGeoJSONLayer();
                selectFeature(feature.properties._internalId);
            });
        }
        function deleteFeature(featureToDelete) {
            appState.map.closePopup();
            showConfirm('Delete Annotation', `Are you sure you want to delete "${featureToDelete.properties.Name || 'this feature'}"?`, () => {
                appState.data.geojson.data.features = appState.data.geojson.data.features.filter(f => f.properties._internalId !== featureToDelete.properties._internalId);
                document.getElementById('snapshot-container').innerHTML = '<p>Select an annotation from the legend or map to view its details.</p>';
                renderGeoJSONLayer();
            });
        }

        // --- 7. UI RENDERING (Snapshot, Legend, Category Manager) ---
        function renderSnapshot(feature) {
            const container = document.getElementById('snapshot-container');
            container.innerHTML = '';
            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'mb-4';
            let detailsHtml = `<h3 class="text-lg font-bold text-gray-900">${feature.properties.Name || 'Unnamed Feature'}</h3>`;
            const descriptionContainer = document.createElement('div');
            descriptionContainer.className = 'text-gray-600 prose max-w-none mt-2';
            descriptionContainer.innerHTML = feature.properties.Description || '<p>No description.</p>';
            detailsDiv.innerHTML = detailsHtml;
            detailsDiv.appendChild(descriptionContainer);
            const otherProps = Object.keys(feature.properties).filter(key => !['_internalId', 'Name', 'Description', 'category'].includes(key));
            if (otherProps.length > 0) {
                detailsDiv.innerHTML += '<hr class="my-3">';
                let propsHtml = '<div class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2 text-sm">';
                otherProps.forEach(key => { const value = feature.properties[key]; propsHtml += `<div><strong class="break-all font-medium text-gray-700">${key}:</strong></div><div class="break-all">${typeof value === 'object' ? JSON.stringify(value) : value}</div>`; });
                propsHtml += '</div>';
                detailsDiv.innerHTML += propsHtml;
            }
            container.appendChild(detailsDiv);
            const mapDiv = document.createElement('div');
            mapDiv.id = 'snapshot-map';
            mapDiv.style.height = '300px';
            mapDiv.className = 'rounded-lg border border-gray-300 mt-4 bg-gray-50';
            container.appendChild(mapDiv);
            if (appState.snapshotMap) appState.snapshotMap.remove();
            if (!feature.geometry) { mapDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">No geometry to display</div>'; return; }
            try {
                const featureLayer = L.geoJSON(feature);
                const bounds = featureLayer.getBounds();
                appState.snapshotMap = L.map('snapshot-map', { zoomControl: false, attributionControl: false, scrollWheelZoom: false, doubleClickZoom: false, dragging: false }).fitBounds(bounds, { padding: [20, 20], maxZoom: 19 });
                if (appState.data.ortho.layer) { new GeoRasterLayer({ georaster: appState.data.ortho.georaster, opacity: 1, resolution: 128 }).addTo(appState.snapshotMap); }
                else { L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { crossOrigin: true }).addTo(appState.snapshotMap); }
                L.geoJSON(feature, { style: getStyleForFeature(feature), pointToLayer: (f, latlng) => createPointMarker(f, latlng) }).addTo(appState.snapshotMap);
            } catch (e) { console.error("Snapshot error:", e); mapDiv.innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">Invalid geometry for snapshot</div>'; }
        }
        function renderLegend() {
            const container = document.getElementById('legend-content');
            container.innerHTML = '';
            const categories = appState.data.categories;
            const features = appState.data.geojson?.data?.features || [];
            if (Object.keys(categories).length === 0) { container.innerHTML = '<p class="text-gray-500 text-sm">No categories defined.</p>'; return; }
            for (const categoryName in categories) {
                const featuresInCategory = features.filter(f => f.properties.category === categoryName);
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'legend-category';
                const header = document.createElement('div');
                header.className = 'legend-category-header';
                header.innerHTML = `<div class="flex items-center"><input type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 mr-2 category-visibility-toggle" checked><span class="font-semibold">${categoryName}</span></div><span class="text-sm text-gray-500">(${featuresInCategory.length})</span>`;
                const itemList = document.createElement('div');
                itemList.className = 'legend-item-list space-y-1 mt-1';
                featuresInCategory.forEach(feature => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.dataset.featureId = feature.properties._internalId;
                    const style = getStyleForFeature(feature);
                    const swatch = document.createElement('div');
                    swatch.className = 'legend-swatch';
                    if (feature.geometry.type.includes('Point')) { swatch.style.backgroundColor = style.color; swatch.style.borderRadius = style.shape === 'circle' ? '50%' : '0'; }
                    else { swatch.style.backgroundColor = style.fillColor || 'transparent'; swatch.style.borderColor = style.color; swatch.style.borderWidth = '2px'; }
                    item.innerHTML = `<span class="truncate">${feature.properties.Name || 'Unnamed'}</span>`;
                    item.prepend(swatch);
                    item.onclick = () => selectFeature(feature.properties._internalId);
                    itemList.appendChild(item);
                });
                categoryDiv.appendChild(header);
                categoryDiv.appendChild(itemList);
                container.appendChild(categoryDiv);
                header.onclick = (e) => { if (e.target.type === 'checkbox') return; categoryDiv.classList.toggle('open'); itemList.style.display = categoryDiv.classList.contains('open') ? 'block' : 'none'; };
                header.querySelector('.category-visibility-toggle').onchange = (e) => {
                    const isVisible = e.target.checked;
                    featuresInCategory.forEach(f => {
                        const layer = appState.featureIdToLayerMap.get(f.properties._internalId);
                        if (layer) { if (isVisible) appState.geojsonLayer.addLayer(layer); else appState.geojsonLayer.removeLayer(layer); }
                    });
                };
            }
        }
        function renderCategoryManager() {
            const container = document.getElementById('category-manager-content');
            container.innerHTML = '';
            let catIndex = 0;
            for (const categoryName in appState.data.categories) {
                const category = appState.data.categories[categoryName];
                const itemDiv = document.createElement('div');
                itemDiv.className = 'category-item';
                itemDiv.id = `cat-item-${catIndex}`;
                itemDiv.innerHTML = `
                    <div class="category-item-header"><span class="font-bold">${categoryName}</span><div><button class="rename-cat-btn text-sm text-blue-600 hover:underline mr-2">Rename</button><button class="delete-cat-btn text-sm text-red-600 hover:underline">&times; Delete</button></div></div>
                    <div class="category-item-body">
                        ${createStyleSectionHTML(catIndex, 'point', 'Point Style', category.styles.point)}
                        ${createStyleSectionHTML(catIndex, 'line', 'Line Style', category.styles.line)}
                        ${createStyleSectionHTML(catIndex, 'polygon', 'Polygon Style', category.styles.polygon)}
                    </div>`;
                container.appendChild(itemDiv);
                catIndex++;
            }
            addCategoryEventListeners();
        }
        function createStyleSectionHTML(catIndex, type, title, style) {
            const dashMap = { solid: 'solid', '10, 5': 'dashed', '2, 5': 'dotted' };
            const idPrefix = `cat${catIndex}-${type}`;
            let controls = '';
            if (type === 'point') {
                controls = `
                    <div class="style-control"><label for="${idPrefix}-color">Color</label><input type="color" id="${idPrefix}-color" value="${style.color}"></div>
                    <div class="style-control"><label for="${idPrefix}-size">Size (px)</label><input type="number" id="${idPrefix}-size" value="${style.size}" min="1"></div>
                    <div class="style-control"><label for="${idPrefix}-shape">Symbol</label><select id="${idPrefix}-shape"><option value="circle" ${style.shape === 'circle' ? 'selected' : ''}>Circle</option><option value="square" ${style.shape === 'square' ? 'selected' : ''}>Square</option><option value="svg" ${style.shape === 'svg' ? 'selected' : ''}>Custom SVG</option></select></div>
                    <div class="mt-2 svg-container ${style.shape !== 'svg' ? 'hidden' : ''}"><label for="${idPrefix}-svg" class="block text-sm font-medium text-gray-700 mb-1">SVG Code</label><textarea id="${idPrefix}-svg" rows="3" class="block w-full border-gray-300 rounded-md shadow-sm">${style.svg || ''}</textarea></div>`;
            } else if (type === 'line') {
                controls = `<div class="style-control"><label for="${idPrefix}-color">Line Color</label><input type="color" id="${idPrefix}-color" value="${style.color}"></div><div class="style-control"><label for="${idPrefix}-weight">Line Width</label><input type="number" id="${idPrefix}-weight" value="${style.weight}" min="0"></div><div class="style-control"><label for="${idPrefix}-dashArray">Line Style</label><select id="${idPrefix}-dashArray"><option value="solid" ${dashMap[style.dashArray] === 'solid' ? 'selected' : ''}>Solid</option><option value="dashed" ${dashMap[style.dashArray] === 'dashed' ? 'selected' : ''}>Dashed</option><option value="dotted" ${dashMap[style.dashArray] === 'dotted' ? 'selected' : ''}>Dotted</option></select></div>`;
            } else if (type === 'polygon') {
                controls = `<div class="style-control"><label for="${idPrefix}-fillColor">Fill Color</label><input type="color" id="${idPrefix}-fillColor" value="${style.fillColor}"></div><div class="style-control"><label for="${idPrefix}-fillOpacity">Fill Opacity</label><input type="range" id="${idPrefix}-fillOpacity" value="${style.fillOpacity}" min="0" max="1" step="0.1"></div><div class="style-control"><label for="${idPrefix}-color">Outline Color</label><input type="color" id="${idPrefix}-color" value="${style.color}"></div><div class="style-control"><label for="${idPrefix}-weight">Outline Width</label><input type="number" id="${idPrefix}-weight" value="${style.weight}" min="0"></div><div class="style-control"><label for="${idPrefix}-dashArray">Outline Style</label><select id="${idPrefix}-dashArray"><option value="solid" ${dashMap[style.dashArray] === 'solid' ? 'selected' : ''}>Solid</option><option value="dashed" ${dashMap[style.dashArray] === 'dashed' ? 'selected' : ''}>Dashed</option><option value="dotted" ${dashMap[style.dashArray] === 'dotted' ? 'selected' : ''}>Dotted</option></select></div>`;
            }
            return `<div class="style-section" data-style-type="${type}"><h4>${title}</h4>${controls}</div>`;
        }
        function addCategoryEventListeners() {
            document.querySelectorAll('.category-item-header').forEach(header => { header.onclick = (e) => { if (e.target.tagName === 'BUTTON') return; header.parentElement.classList.toggle('open'); }; });
            document.querySelectorAll('.delete-cat-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const categoryName = e.target.closest('.category-item-header').querySelector('span').innerText;
                    showConfirm('Delete Category and all its features?', `This will delete the "${categoryName}" category and ALL annotations assigned to it. This action cannot be undone.`, () => {
                        appState.data.geojson.data.features = appState.data.geojson.data.features.filter(f => f.properties.category !== categoryName);
                        delete appState.data.categories[categoryName];
                        renderCategoryManager();
                        renderGeoJSONLayer();
                    });
                };
            });
             document.querySelectorAll('.rename-cat-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const oldName = e.target.closest('.category-item-header').querySelector('span').innerText;
                    showPrompt('Rename Category', [{ id: 'newName', label: 'New Category Name', value: oldName, type: 'text' }], (results) => {
                        const newName = results.newName.trim();
                        if (newName && newName !== oldName && !appState.data.categories[newName]) {
                            appState.data.categories[newName] = appState.data.categories[oldName];
                            delete appState.data.categories[oldName];
                            appState.data.geojson.data?.features.forEach(f => { if (f.properties.category === oldName) f.properties.category = newName; });
                            renderCategoryManager();
                            renderGeoJSONLayer();
                        } else if (appState.data.categories[newName]) { showMessage('Error', 'A category with that name already exists.'); }
                    });
                };
            });
            document.querySelectorAll('.style-section input, .style-section select, .style-section textarea').forEach(input => {
                input.onchange = (e) => {
                    const target = e.target;
                    const categoryName = target.closest('.category-item').querySelector('.category-item-header span').innerText;
                    const styleType = target.closest('.style-section').dataset.styleType;
                    const prop = target.id.split('-').pop();
                    let value = target.value;

                    if (target.type === 'number' || target.type === 'range') value = parseFloat(value);
                    if (prop === 'dashArray') value = { solid: 'solid', dashed: '10, 5', dotted: '2, 5' }[value];
                    
                    appState.data.categories[categoryName].styles[styleType][prop] = value;

                    if (prop === 'shape') {
                        const container = target.closest('.style-section').querySelector('.svg-container');
                        if (container) container.classList.toggle('hidden', value !== 'svg');
                    }
                    
                    renderGeoJSONLayer();
                };
            });
        }
        function toggleLabels(show, force) {
            const newState = force ? show : !appState.labelsVisible;
            if (newState === appState.labelsVisible && !force) return;
            appState.labelsVisible = newState;
            appState.featureIdToLayerMap.forEach(layer => {
                if (appState.labelsVisible) layer.openTooltip();
                else layer.closeTooltip();
            });
            document.getElementById('toggle-labels-btn').innerText = appState.labelsVisible ? 'Hide Labels' : 'Show Labels';
        }

        // --- 8. EVENT LISTENERS & APP STARTUP ---
        function initializeEventListeners() {
            document.getElementById('logo-input').addEventListener('change', async (e) => { const file = e.target.files[0]; if (file) { appState.data.logo = await readFile(file, 'dataURL'); document.getElementById('logo-img').src = appState.data.logo; } });
            document.getElementById('logo-img').onclick = () => document.getElementById('logo-input').click();
            document.getElementById('edit-header-btn').addEventListener('click', () => { showPrompt('Edit Header', [{ id: 'newTitle', label: 'New Title', value: document.getElementById('main-title').innerText, type: 'text' }, { id: 'Description', label: 'New Description', value: document.getElementById('main-description').innerHTML, type: 'quill' }], (results) => { if (results.newTitle !== null) document.getElementById('main-title').innerText = results.newTitle; if (results.Description !== null) document.getElementById('main-description').innerHTML = results.Description; }); });
            document.getElementById('ortho-input').addEventListener('change', (e) => handleRasterUpload(e, 'ortho'));
            document.getElementById('dsm-input').addEventListener('change', (e) => handleRasterUpload(e, 'dsm'));
            document.getElementById('geojson-input').addEventListener('change', handleGeoJSONUpload);
            document.getElementById('manage-categories-btn').onclick = () => categoryManagerPanel.classList.add('open');
            document.getElementById('close-category-manager-btn').onclick = () => categoryManagerPanel.classList.remove('open');
            document.getElementById('add-category-btn').onclick = () => {
                showPrompt('Add New Category', [{ id: 'name', label: 'Category Name', value: '', type: 'text' }], (results) => {
                    const name = results.name.trim();
                    if (name && !appState.data.categories[name]) {
                        appState.data.categories[name] = { styles: { point: { color: '#ff8c00', size: 16, shape: 'circle', svg: '' }, line: { color: '#ff4500', weight: 3, dashArray: 'solid' }, polygon: { fillColor: '#ff6347', fillOpacity: 0.2, color: '#ff6347', weight: 3, dashArray: 'solid' } } };
                        renderCategoryManager();
                        renderLegend();
                    } else if (appState.data.categories[name]) { showMessage('Error', 'A category with that name already exists.'); }
                });
            };
            document.getElementById('toggle-labels-btn').onclick = () => toggleLabels();
            document.getElementById('export-btn').addEventListener('click', async () => {
                showLoader('Generating Report...');
                try {
                    const zip = new JSZip();
                    const fullScript = document.querySelector('script:not([src])').innerHTML;
                    const viewOnlyScript = `document.addEventListener('DOMContentLoaded', () => { document.querySelectorAll('input[type="file"], button').forEach(el => el.remove()); ${fullScript} });`;
                    const clonedDoc = document.cloneNode(true);
                    clonedDoc.querySelector('script:not([src])').innerHTML = viewOnlyScript;
                    clonedDoc.getElementById('export-btn').parentElement.innerHTML = '<p class="text-gray-600">This is a view-only exported report.</p>';
                    zip.file("report.html", clonedDoc.documentElement.outerHTML);
                    const dataFolder = zip.folder("data");
                    if (appState.data.logo) dataFolder.file("logo.png", appState.data.logo.split(',')[1], { base64: true });
                    if (appState.data.ortho.fileBuffer) dataFolder.file("ortho.tif", appState.data.ortho.fileBuffer);
                    if (appState.data.dsm.fileBuffer) dataFolder.file("dsm.tif", appState.data.dsm.fileBuffer);
                    if (appState.data.geojson.data) {
                        const geojsonToSave = JSON.parse(JSON.stringify(appState.data.geojson.data));
                        geojsonToSave.features.forEach(f => { delete f.properties._internalId; });
                        geojsonToSave.properties = { categories: appState.data.categories };
                        dataFolder.file("annotations.geojson", JSON.stringify(geojsonToSave, null, 2));
                    }
                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(zipBlob);
                    link.download = "Geospatial-Report.zip";
                    link.click();
                    URL.revokeObjectURL(link.href);
                } catch(error) { console.error("Export failed:", error); showMessage("Export Error", "Could not generate the report ZIP file."); }
                finally { hideLoader(); }
            });
        }

        // --- APPLICATION STARTUP ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeMap();
            initializeEventListeners();
            renderCategoryManager();
            renderLegend();
        });

    </script>

</body>
</html>
